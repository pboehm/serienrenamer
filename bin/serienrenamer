#!/usr/bin/env ruby
# -*- ruby -*-
# encoding: UTF-8

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')

require 'serienrenamer'
require 'plugin'
require 'optparse'
require 'fileutils'
require 'highline/import'

###
# Option definition and handling
options = {}
opts = OptionParser.new("Usage: #{$0} [OPTIONS] DIR")

opts.on( "-p", "--plugin STRING", String,
         "use only this plugin") do |opt|
    options[:plugin] = opt
end

opts.on( "-s", "--series STRING", String,
         "series name that will be set for all episodes") do |opt|
    options[:series] = opt
end

opts.on( "-i", "--[no-]ignore-filenamedata", 
         "Always ask plugins for episode information") do |opt|
    options[:ignore_filenamedata] = opt
end

opts.separator("  Ruby Script that brings your series into an")
opts.separator("  appropriate format like 'S01E01 - Episodename.avi'")
opts.separator("")
opts.separator("  Options:")

opts.separator("")
opts.separator("  Arguments:")
opts.separator("     DIR      The path that includes the episodes")
opts.separator("              defaults to ~/Downloads")
opts.separator("")

rest = opts.permute(ARGV)
###
# Load plugins
Dir[File.join(File.dirname(__FILE__),"../lib/plugin/*.rb")].each do |plugin|
	load plugin
end
Serienrenamer::Pluginbase.registered_plugins.sort! {|x,y| y.priority <=> x.priority }

puts "Plugins loaded: #{Serienrenamer::Pluginbase.registered_plugins.inspect}"
puts ""

###
# cycle all episodes
episode_directory = rest.pop || File.join( File.expand_path('~'), "Downloads" )

fail "'#{episode_directory}' does not exist or is not a directory" unless
    Dir.exists?(episode_directory)

Dir.chdir(episode_directory)

# Iterate through all directory entries
for entry in Dir.entries('.').sort do

    next if entry.match(/^\./)
    next unless Serienrenamer::Episode.determine_video_file(entry)

    puts "<<< #{entry}"
    
    begin
        epi = Serienrenamer::Episode.new(entry)
        if options[:series]
            epi.series = options[:series]
        end
    rescue => e
        puts "Episode object can't be instantiated, will skip this\n"
        next 
    end

    # if episodename is empty than query plugins
    if epi.episodename.match(/\w+/).nil? || options[:ignore_filenamedata]
 
        Serienrenamer::Pluginbase.registered_plugins.each do |plugin|  
            next unless plugin.usable
            if options[:plugin]
                next unless plugin.plugin_name.match(/#{options[:plugin]}/i)
            end

            epiname = plugin.generate_episode_information(epi)[0]
            next if epiname == nil

            puts "[#{plugin.plugin_name}] - #{epiname}"

            epi.add_episodename(epiname, true)
            break
        end
    end

    puts ">>> #{epi.to_s}"
    
    next unless  agree("Filename okay? (y/n) ", true)

    epi.rename()

    puts ""
end
